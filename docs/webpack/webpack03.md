## webpack解决了什么问题？有哪些优点？

### 我们为什么要用webpack

在前端发展历史上，对于模块化的演变，我们经历过以下几个层次：

**一、项目中所需的js文件由不同js文件完成，全部引入，一起加载**

带来的问题：

1、模块直接在全局工作，大量模块成员污染全局作用域；

2、没有私有空间，所有模块内的成员都可以在模块外部被访问或者修改；

3、一旦模块增多，容易产生命名冲突；

4、无法管理模块与模块之间的依赖关系；

5、在维护的过程中也很难分辨每个成员所属的模块；

**二、每个模块（js文件）暴露一个全局对象，所有模块成员都挂在到这个全局对象中**

带来的问题：

只是解决了命名的问题，但其他问题依然存在。

1.引入资源的时候每一个js都要引入一次，每引入一次js文件就会多一次HTTP请求，当资源过多时，容易导致页面加载速度慢.

2.资源引入的顺序有要求,比如上面index.js一定要放到最后不然就会报错，而且在index.js文件中看不到具体哪行代码对应哪个js文件，而且不好定位错误的位置，不容易维护。

3.目录结构不清晰，不能通过index.js知道Header、Sidebar、Content文件所在得位置.

**三、使用IIFE(立即执行函数)为模块提供私有空间，其参数可以作为依赖声明使用**

带来的问题：解决了依赖问题和全局作用域的问题。但对于模块的加载问题依然没有解决。

上面不管哪种方式，都是通过script标签的方式在页面中直接引入这些模块，模块的顺序问题以及对模块的修改，但html中忘记修改或者忘记引入or删除，就可能会影响到页面加载。

因此，鉴于上述带来的问题，需要一个统一标准去规范模块化的实现。

在实现模块化过程中，出现过AMD(Asynchronous Module Definition)规范,即异步模块定义规范;CMD规范(代表的是Sea.js);CommonJS;ES Modules

webpack就是基于此发展而来，成为比较优秀的前端打包工具。

**总结：webpack实现了前端项目的模块化，在前端项目中，高效管理和维护项目中的每一个资源。**

### webpack有哪些优点？

1、以commonJS的形式来书写脚本，对AMD、CMD的支持也很全面，方便旧项目的迁移

2、代码转换：能被模块化的不止是JS，还有html，css，图片,typescript等

3、代码优化： 压缩HTML、css代码,图片转base64等；

4、代码分割： 将通用的代码从多个文件中抽取出来；大文件切割成小文件；

5、模块合并： 模块化项目里会有很多模块，比如一个模块引用了另一个模块这样子。构建工具可以将多个模块合并成一个模块；

6、自动刷新： 监听代码的变化，对代码进行实时刷新；

7、在代码提交到代码仓库之前进行代码校验，看是否符合规范或者单元测试是否通过；

8、自动发布： 代码更新完毕之后，自动构建发布代码并传输给发布系统进行发布。

9、扩展性强，插件机制完善





