 ### 一、什么是垃圾回收
我们在使用变量的时候，会为局部变量在栈内存上分配相应的空间，以便存储他们的值。然后在函数中是用这些变量，直至函数执行结束。因此释放这部分的内存以供将来使用。处理这部分的变量，就叫做垃圾回收。
JS是具有自动垃圾收集机制，也就是执行环境会负责管理代码执行过程中使用的内存。这个操作叫做垃圾回收。
但并非所有情况都能判断出变量是否还有存在的必要。JS中的垃圾收集器必须根据哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备回收其内存。通常有两种方式：
### 二、垃圾回收的方法
1、标记清除
原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。
工作流程：
1. 垃圾收集器在运行的时候回给存储在内存中的所有变量都加上标记
2. 去掉环境中的变量以及被环境中的变量引用的变量的标记
3. 再被加上标记的变量将被视为准备删除的变量
4. 垃圾收集器完成内存清除工作。
2、引用计数
原理：跟踪记录每个值被引用的次数。当引用次数为0的时候，将被收集
工作流程：
1. 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。
2. 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.
3. 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.
4. 当引用次数变成0时，说明没办法访问这个值了。
5. 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。
问题：循环引用（或者说相互引用）。循环引用就是对象A中包含另一个指向对象B的指针，B中也包含一个指向A的引用。
比如：
```
<script type="text/javascript">
  function fn(){
    var a={};
    var b={};
    a.someOtherObj = b;
    b.anotherObj = a;
  }
</script>
```
比如上面的代码，对象a和b通过各自的属性相互引用，这两个对象的引用次数都是2，在引用计数策略中，当函数函数执行完毕后，对象依然存在，当多次使用，就会产生大量内存得不到回收。
在IE中，IE的JS引擎使用标记清除方法实现，但其BOM和DOM对象采用的是C++以COM对象的形式实现的，COM对象的垃圾收集机制使用的就是引用计数方法。因此也会产生循环引用的问题。
### 三、如何解除
原因：
JS在进行内存管理及垃圾收集和其他开发语言不一样，就是分配给web浏览器的可用内存数量通常要比分配给桌面应用程序的少。原因就是避免网页耗尽全部内存导致系统崩溃。
如何管理这方面的内存？
就是为执行中的代码只保存必要的数据，一旦数据不再有用，就通过将值设置为null来释放引用。在局部作用域中，当函数执行完毕的时候，局部变量也就没有存在的必要了，因此垃圾回收器很容易做出判断并回收。但全局变量很难判断什么时候自动释放内存，所以设置为null多适用于全局变量和全局对象的属性。
```
var a = 20; // 在内存中给数值变量分配空间
alert(a + 100); // 使用内存
a = null ; // 使用完毕
```
### 四、内存泄漏
所谓内存泄漏就是内存没有被操作系统回收，存放在系统中。
以下几种情况会导致内存泄漏：
1、意外的全局变量引起的内存泄漏。
     原因：全局变量，不会被回收。
     解决：尽量不使用全局变量，如果使用了，在用不到的时候，置为null
 2.    闭包引起的内存泄漏
原因：闭包可以维持函数内局部变量，使其得不到释放。
解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。
```
function my(name) {
    function sendName() {
        console.log(name)
    }
    return sendName
}
var test=my("tokey")
test()  //tokey
```
在my()内部创建的sendName()函数是不会被回收的，因为它被全局变量test引用，处于随时被调用的状态。如果向释放内存可以设置test=null;由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。
### 3.没有清理的DOM元素引用
浏览器中DOM和js采用的是不一样的引擎，DOM采用的是渲染引擎，而js采用的是v8引擎，所以在用js操作DOM时会比较耗费性能，因为他们需要桥来链接他们。我们会采用变量引用的方式会将其缓存在当前环境。如果在进行一些删除、更新操作之后，可能会忘记释放已经缓存的DOM
解决：在删除更新等操作后应该将其设置为null
### 4.被遗忘的定时器或者回调
原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。
解决：手动删除定时器和dom。
### 5.子元素存在引用引起的内存泄漏
原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。
解决：手动删除清空。