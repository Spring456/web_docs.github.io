# 事件循环机制（JS渲染机制）

### 先来个面试题吧
```javascript
    for(var i=0;i<5;i++){
        setTimeout(()=>{
            console.log(i)
        },0)
    }
```
这是一个很老套但很经典的面试题。上面运行结果是什么呢？结果为5个5；那这是为什么呢？想了解这其中的原理，我们就要了解JS渲染的机制问题。
### 1.JS单线程
JavaScript是单线程的，也就是说，同一时间只能做一件事。

单线程就意味着：所有任务需要排队执行，前一个任务执行完毕，才会执行下一个任务。

主线程从'任务队列'中读取执行事件，不断循环重复的过程，就叫做'事件循环'。如果一个任务耗时太长，后面的事件就不得不一直等着，那么我们肯定就要对这种情况进行处理。

为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。
### 任务队列
单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。

如果前一个任务耗时很长，后一个任务就不得不一直等着。所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。

同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；

异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。具体来说，异步执行的运行机制如下:（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）

>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

>（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

>（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

>（4）主线程不断重复上面的第三步。

只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

### EventLoop 事件循环
主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。
![alt 事件循环图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e14aff1f40684c48b93ea48cdb4661f4~tplv-k3u1fbpfcp-zoom-1.image)

1.整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”；

2.同步任务会直接进入主线程依次执行；形成一个'执行栈'

3.主线程之外，存在一个'任务队列',在走主流程的时候，如果碰到异步任务，那么就在'任务队列'中放置这个异步任务。

4.当'执行栈'中的同步任务都执行完毕后，系统就会读取'任务队列',看看里面存在哪些事件，哪些对应异步任务，然后依次进入执行栈，开始执行。

3.异步任务会再分为宏任务和微任务；

4.宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中；

5.微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中；

6.当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务；也就是先执行微任务，再执行宏任务

7.上述过程会不断重复，这就是Event Loop事件循环；
### 哪些是异步任务？
1.setTimeout 和 setInterval

2.DOM 事件

3.Promise

4.网络请求

5.I/O
### 宏任务 & 微任务
任务队列中，又分为宏任务和微任务

这里需要注意的是new Promise是会进入到主线程中立刻执行，而promise.then则属于微任务
+ 宏任务(macro-task)：整体代码script、setTimeOut、setInterval
+ 微任务(mincro-task)：promise.then、promise.nextTick(node)

### 案例
好，回到我们开始的那个面试题，首先setTimeout定时器属于异步任务，并不会马上把这个异步任务放到任务队列中，而是等时间到了之后才放入，然后等执行栈中的同步任务执行完毕之后，再从任务队列中取出任务执行。

for循环属于同步任务，会先执行完循环，此时i的值是5，同步任务执行完毕之后，才开始来执行异步任务，console.log(i)被依次放入任务队列中，所以打印出来5个5

如何解决呢？最简单的方法就是将其中的var改为let即可，这是为什么呢？

因为let在for循环中，会形成独特的作用域块，当前的i只在本轮循环中有效，然后在setTimeout会找到本轮循环的i值，从而依次输出1-5

使用var会污染全局变量，所以在for循环外我们还可以看到i值。

1>第一题
```
console.log(1);
setTimeout(function(){
  console.log(2)
}, 0);
console.log(3)
```
答案：1，3，2

解析： console.log() 是同步任务， setTimeout 是异步任务。异步任务会等同步任务执行完再执行。虽然 setTimeout 设置的延迟是 0，但浏览器规定延迟最小为 4ms，所以 console.log(2) 在 4ms 后被放入任务队列。当同步任务执行完，即打印完 1，3 之后，主线程再从任务队列中取任务，打印 2。

2> 第二题
```
console.log('A')
while(true){}
console.log('B')

```
答案：A

解析：代码从上往下执行，先打印 A，然后 while 循环，因为条件一直是 true，所以会进入死循环。while 不执行完就不会执行到第三行。

3> 第三题
```
setTimeout(function(){
    console.log(1)
});
new Promise(function(resolve){
    console.log(2);
    for(var i = 0; i < 10000; i++){
        i == 9999 && resolve();
    }
}).then(function(){
    console.log(3)
});
console.log(4);


```
结果： 2， 4， 3， 1

分析：1.setTimeout是异步，且是宏函数，放到宏函数队列中；2.new Promise是同步任务，直接执行，打印2，并执行for循环；3.promise.then是微任务，放到微任务队列中；4.console.log(4)同步任务，直接执行，打印4；5.此时主线程任务执行完毕，检查微任务队列中，有promise.then，执行微任务，打印3；6.微任务执行完毕，第一次循环结束；从宏任务队列中取出第一个宏任务到主线程执行，打印1；7.结果：2，4，3，1